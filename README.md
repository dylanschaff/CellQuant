# CellQuant
These functions use cell masks to help you learn about cells in an image.

(To generate cell masks you may want to check out: https://github.com/SydShafferLab/DeepCellHelper)

## List of functions

```python
MaskCheck(img_path, mask_path, channel=1, min_brightness=.15):
```
MaskCheck outlines the masks on top of the original image to check if the masks are doing a good job capturing the cell (outputs a jpeg). 
The inputs to this function are the path to the raw tif image (img_path) and the path to the mask file you want to check (mask_path) (the input mask file should be a tif file where each mask has a unique intensity). Optionally, you can enter which channel you want the mask to be overlayed on (default is 1 (uses base 1)). If the output image brightness does not look right, you can also change the optional min_brighness parameter.

Example output:

<img src="https://github.com/gharmange/CellQuant/blob/main/Images/MaskCheck_example.png" width="250" height="250">

```python
MaskPos(Mask_path)
```
MaskPos generates a numpy array and csv file containing each mask’s x and y coordinates from a mask file. The input to this function is the path to a mask file (Mask_path) (input mask file should be a tif file where each mask has a unique intensity). The csv file will be output
in the same directory of the input mask file with "_Cellxy.csv" at the end of the file name.

```python
MaskQuant(Image_path,Mask_path,CHANNELS)
```
MaskQuant generates a table containing the mean and sum intensities within each mask. The inputs to this function are: the path to the raw image you are quantifying (Image_path), the path to the mask you are quantifying (Mask_path) (input mask file should be a tif file where each mask has a unique intensity),
and a list of the channels you want to quantify (CHANNELS). The CHANNELS list is base 1, for example, to quantify channel 1 input: [1], to quantify channel 1 and 3 input: [1,3]. The output csv will be in the same directory as the input mask file.

```python
TestRad(path,radius_um,objective)
```
One metric that may be of interest is how dense your cells are. We find that a good way to calculate the density for each cell is to determine how many cells are within a given radius of each cell. To quickly test what radius
gives a good density metric for your cells, use TestRad show the size of the radius in the context of the xy coordinates. The inputs to this function are: the path to a file containing xy coordinates of masks generated by the MaskPos function (path), the radius you would like to try in um (radius_um),
and what objective was used to take the image (objective) (can input '10x' or '20x'). NOTE: the accuracy of the um value depends on the scope used and may need to be changed in the function if you are not using images taken on the Shaffer Lab scope. The output of this function is a png showing the a circle with the specified radius in the context of the cells and will be in the same directory as the input xy coordinate file.

Example output:

<img src="https://github.com/gharmange/CellQuant/blob/main/Images/TestRad_example.png" width="500" height="500">

```python
DensityQuant(path,radius_um,objective)
```
DensityQuant generates a density metric for each cell by determining how many cells are with a given radius of each cell. The inputs to this function are: the path to a folder containing xy coordinates of masks generated by the MaskPos function (path),
the radius you would like to use in um (radius_um), and what objective was used to take the image (objective) (can input '10x' or '20x'). NOTE: the accuracy of the um value depends on the scope used and may need to be changed in the function if you are not using images taken on the Shaffer Lab scope. The output csv contains the density metric for each cell and will be in the same directory as the xy coordinate input files. An additional csv called "WholeWellDensities.csv" gives the mean and median density to the input file.

```python
PlotDensity(path)
```
PlotDesity generates a scatter plot showing the density metric of each cell using a heatmap. The input to this function is a table containing the density metric of each cell created with the DensityQuant function. The output of this function is a png showing the density value of each cell as a heatmap and will be in the same dierectory as the input xy coordinate file.

Example output:

<img src= "https://github.com/gharmange/CellQuant/blob/main/Images/DensityPlot_example.png" width="500" height="500">

```python
MakeCytoMask(nucPath)
```
makeCytoMask generates a mask to sample the cytoplasm of cells based on a nuclear mask. The input to this function is the path to the nuclear mask file (nucPath) (input mask file should be a tif file where each mask has a unique intensity). The output is a tif file containing a cytoplasm mask with the same intensity value as its corresponding nuclear mask and will be in the same directory as the input mask file. (Function written by Shivani Nellore)

```python
CytoNucRatios(Image_path, Mask_path_Nuc, Mask_path_cyto,CHANNELS)
```
CytoNucRatios calculates the cytoplasm to nuclear ratio (both mean and median) and records each cell’s nuclear and cytoplasm size. The inputs to this function are: the path to the raw image in the tif format (Image_path), the path to the nuclear masks (Mask_path_Nuc),
the path to the cytoplasm mask (Mask_path_cyto), and the list of channels you would like to run cytoplasm to nuclear ratio on (CHANNELS). The Mask files should be tif files where each mask has a unique intensity, and the matched nuclear and cytoplasm masks should have the 
same intensity values. The CHANNELS list is base 1, for example, to quantify channel 1 input: [1], to quantify channel 1 and 3 input: [1,3]. The output csv contains the cytoplasm to nuclear ratio as calculated by mean and median intensity, as well as the size of the cytoplasm and nucleus of each cell. The output csv will be in the same directory as the input nuclear mask file.
(function written in collaboration with Shivani Nellore)
